import { AskNewsSDK } from '@emergentmethods/asknews-typescript-sdk';
import dayjs from 'dayjs';
import chalk from "chalk";
import fs from 'fs/promises';
import path from 'path';

import 'dotenv/config'

const ASKNEWS_CLIENT_ID = process.env.ASKNEWS_CLIENT_ID;
const ASKNEWS_SECRET = process.env.ASKNEWS_SECRET;

const ask = new AskNewsSDK({
    clientId: ASKNEWS_CLIENT_ID,
    clientSecret: ASKNEWS_SECRET,
    scopes: ['news', 'stories', 'chat'],
    // scopes: ['news', 'stories', 'forecast'],
})

const formatAskNewsContext = (hotArticles, historicalArticles) => {
    let formattedArticles = "Here are the relevant news articles:\n\n";

    if (hotArticles.length > 0) {
        hotArticles.sort((a, b) => new Date(b.pub_date) - new Date(a.pub_date));
        hotArticles.forEach(article => {
            const pubDate = dayjs(article.pub_date).format("MMMM DD, YYYY hh:mm A");
            formattedArticles += `**${article.eng_title}**\n${article.summary}\nOriginal language: ${article.language}\nPublish date: ${pubDate}\nSource:[${article.source_id}](${article.article_url})\n\n`;
        });
    }

    if (historicalArticles.length > 0) {
        historicalArticles.sort((a, b) => new Date(b.pub_date) - new Date(a.pub_date));
        historicalArticles.forEach(article => {
            const pubDate = dayjs(article.pub_date).format("MMMM DD, YYYY hh:mm A");
            formattedArticles += `**${article.eng_title}**\n${article.summary}\nOriginal language: ${article.language}\nPublish date: ${pubDate}\nSource:[${article.source_id}](${article.article_url})\n\n`;
        });
    }

    if (hotArticles.length === 0 && historicalArticles.length === 0) {
        formattedArticles += "No articles were found.\n\n";
    } else {
        formattedArticles += `*Generated by AI at [AskNews](https://asknews.app), check out the [API](https://docs.asknews.app) for more information*.`;
    }

    return formattedArticles;
};

const getAskNewsContext = async (query) => {
    const hotResponse = await ask.news.searchNews({
        query,
        n_articles: 5,
        return_type: "both",
        strategy: "latest news",
        diversify_sources: true,
    });

    const historicalResponse = await ask.news.searchNews({
        query,
        n_articles: 20,
        return_type: "both",
        strategy: "news knowledge",
        diversify_sources: true,
    });

    const llmContext = hotResponse.asString + historicalResponse.asString;
    const formattedArticles = formatAskNewsContext(hotResponse.asDicts, historicalResponse.asDicts);
    return { llmContext, formattedArticles };
};

const parseAskNewsArticles = (sources) => {
    let formattedArticles = "";
    sources.forEach(article => {
        const pubDate = dayjs(article.pub_date).format("MMMM DD, YYYY hh:mm A");
        formattedArticles += `**${article.engTitle}**\n${article.summary}\nOriginal language: ${article.language}\nPublish date: ${pubDate}\nSource:[${article.sourceId}](${article.articleUrl})\n\n`;
    })
    return formattedArticles;
}

const parseWebResults = (webResults) => {
    let formattedResults = "";
    webResults.forEach(result => {
        formattedResults += `**${result.title}**\n${result.source}\nKey Points: ${result.keyPoints && result.keyPoints.length ? result.keyPoints.map(k => `${k}\n`).join('') : 'none'}\n\n`;
    })
    return formattedResults;

}

const parseAskNewsForecast = (forecast) => {
    return {
        probability: forecast.probability,
        forecast: forecast.forecast,
        reasoning: forecast.reasoning,
        formatted: `# ASKNEWS Forecast:\n ${forecast.forecast}\n\n
        ## Resolution Criteria:\n ${forecast.resolutionCriteria}\n\n
        ## Reasoning:\n ${forecast.reasoning}\n\n
        ##Â Timeline to resolution:\n ${forecast.timeline.map(t => `${t}\n`).join('')}\n\n
        ## Probability:\n ${forecast.probability}%\n\n
        ## LLM Confidence (Claude 3.5):\n ${forecast.llmConfidence}\n\n
        ## Key Facets:\n ${forecast.keyFacets.join('\n')}\n\n
        ## Reconciled Information:\n ${forecast.reconciledInformation}\n\n
        ## Summary:\n ${forecast.summary}\n\n
        ## Reconciled Information:\n ${forecast.reconciledInformation}\n\n
        ## Unique Information:\n ${forecast.uniqueInformation}\n\n`
    };

}

const getAskNewsForecast = async (query, additionalContext = '', lookback = 180, articlesToUse = 50) => {
    const response = await ask.forecast.getForecast({
        query,
        lookback,
        articlesToUse,
        model: 'claude-3-5-sonnet-20240620',
        webSearch: true,
        additionalContext,
    })
    return { raw: response, parsed: parseAskNewsForecast(response) };
};

// Helper function to ensure the cache directory exists
async function ensureCacheDirExists(cacheDir) {
    try {
        await fs.access(cacheDir);
    } catch (error) {
        // Directory does not exist, so create it
        await fs.mkdir(cacheDir, { recursive: true });
        console.log(chalk.green(`Created cache directory: ${cacheDir}`));
    }
}

// Helper function to get the forecast with caching
async function getForecastWithCache(id, title, fine_print, duration, limit, forecastType, cacheDir) {
    // Define the cache file path
    const cachePath = path.join(cacheDir, `${id}_${forecastType}.json`);

    // Check for cached forecast
    try {
        const cachedForecast = JSON.parse(await fs.readFile(cachePath, 'utf-8'));
        console.log(chalk.green(`Loaded ${forecastType} forecast from cache`));
        return cachedForecast;
    } catch (error) {
        console.log(chalk.yellow(`Get ${forecastType} forecast`));
        const forecast = await getAskNewsForecast(title, fine_print, duration, limit);
        await fs.writeFile(cachePath, JSON.stringify(forecast));
        console.log(chalk.green(`Saved ${forecastType} forecast to cache`));
        return forecast;
    }
}

async function getForecasts(id, title, fine_print) {

    // Define the cache directory
    const cacheDir = path.join(process.cwd(), 'forecastCache');

    // Ensure the cache directory exists
    await ensureCacheDirExists(cacheDir);

    // Get short-term forecast
    const shortTermForecast = await getForecastWithCache(id, title, fine_print, 30, 50, 'shortTerm', cacheDir);

    // Get long-term forecast
    const longTermForecast = await getForecastWithCache(id, title, fine_print, 360, 100, 'longTerm', cacheDir);

    return { shortTermForecast: shortTermForecast.parsed, longTermForecast: longTermForecast.parsed };
}

export { getAskNewsContext, parseAskNewsForecast, getForecasts };